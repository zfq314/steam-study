id		ts
1001	17523641234
1001	17523641256
1002	17523641278
1001	17523641334
1002	17523641434
1001	17523641534
1001	17523641544
1002	17523641634
1001	17523641638
1001	17523641654
时间间隔小于60秒，则分为同一个组
1001	17523641234		1
1001	17523641256		1
1001	17523641334		2
1001	17523641534		3
1001	17523641544		3
1001	17523641638		4
1001	17523641654		4
1002	17523641278		1
1002	17523641434		2
1002	17523641634		3

1)将上一行时间数据下移
lead:领导
lag:延迟
select
    id,
    ts,
    lag(ts,1,0) over(partition by id order by ts) lagts
from
    test2;t1
1001	17523641234	0
1001	17523641256	17523641234
1001	17523641334	17523641256
1001	17523641534	17523641334
1001	17523641544	17523641534
1001	17523641638	17523641544
1001	17523641654	17523641638
1002	17523641278	0
1002	17523641434	17523641278
1002	17523641634	17523641434

2)将当前行时间数据减去上一行时间数据
select
    id,
    ts,
    ts-lagts tsdiff
from
    t1;t2

select
    id,
    ts,
    ts-lagts tsdiff
from
    (select
    id,
    ts,
    lag(ts,1,0) over(partition by id order by ts) lagts
from
    test2)t1;t2
1001	17523641234	17523641234
1001	17523641256	22
1001	17523641334	78
1001	17523641534	200
1001	17523641544	10
1001	17523641638	94
1001	17523641654	16
1002	17523641278	17523641278
1002	17523641434	156
1002	17523641634	200

3)计算每个用户范围内从第一行到当前行tsdiff大于等于60的总个数(分组号)
select
    id,
    ts,
    sum(if(tsdiff>=60,1,0)) over(partition by id order by ts) groupid
from
    t2;

4)最终HQL
select
    id,
    ts,
    sum(if(tsdiff>=60,1,0)) over(partition by id order by ts) groupid
from
    (select
    id,
    ts,
    ts-lagts tsdiff
from
    (select
    id,
    ts,
    lag(ts,1,0) over(partition by id order by ts) lagts
from
    test2)t1)t2;